{\rtf1\ansi\ansicpg1252\uc1 \deff0\deflang1033\deflangfe1033{\fonttbl{\f0\froman\fcharset0\fprq2{\*\panose 02020603050405020304}Times New Roman;}{\f2\fmodern\fcharset0\fprq1{\*\panose 02070309020205020404}Courier New;}
{\f15\fswiss\fcharset0\fprq2{\*\panose 020b0604030504040204}Tahoma;}{\f16\fnil\fcharset0\fprq0{\*\panose 00000000000000000000}Monospaced;}{\f17\fnil\fcharset0\fprq0{\*\panose 00000000000000000000}Dialog;}
{\f126\froman\fcharset238\fprq2 Times New Roman CE;}{\f127\froman\fcharset204\fprq2 Times New Roman Cyr;}{\f129\froman\fcharset161\fprq2 Times New Roman Greek;}{\f130\froman\fcharset162\fprq2 Times New Roman Tur;}
{\f131\froman\fcharset186\fprq2 Times New Roman Baltic;}{\f138\fmodern\fcharset238\fprq1 Courier New CE;}{\f139\fmodern\fcharset204\fprq1 Courier New Cyr;}{\f141\fmodern\fcharset161\fprq1 Courier New Greek;}
{\f142\fmodern\fcharset162\fprq1 Courier New Tur;}{\f143\fmodern\fcharset186\fprq1 Courier New Baltic;}{\f216\fswiss\fcharset238\fprq2 Tahoma CE;}{\f217\fswiss\fcharset204\fprq2 Tahoma Cyr;}{\f219\fswiss\fcharset161\fprq2 Tahoma Greek;}
{\f220\fswiss\fcharset162\fprq2 Tahoma Tur;}{\f221\fswiss\fcharset186\fprq2 Tahoma Baltic;}}{\colortbl;\red0\green0\blue0;\red0\green0\blue255;\red0\green255\blue255;\red0\green255\blue0;\red255\green0\blue255;\red255\green0\blue0;\red255\green255\blue0;
\red255\green255\blue255;\red0\green0\blue128;\red0\green128\blue128;\red0\green128\blue0;\red128\green0\blue128;\red128\green0\blue0;\red128\green128\blue0;\red128\green128\blue128;\red192\green192\blue192;}{\stylesheet{\widctlpar\adjustright 
\fs20\cgrid \snext0 Normal;}{\*\cs10 \additive Default Paragraph Font;}{\s15\nowidctlpar\adjustright \f16 \snext15 default;}{\s16\nowidctlpar\adjustright \f17\cf1 \sbasedon15 \snext16 default1;}{\s17\widctlpar\adjustright \cbpat9 \f15\fs20\cgrid 
\sbasedon0 \snext17 Document Map;}}{\info{\title Chapter-2: Object Oriented Programming Concepts}{\author Dipak Roy}{\operator Dipak Roy}{\creatim\yr2004\mo9\dy5\hr22\min52}{\revtim\yr2004\mo9\dy5\hr22\min52}{\version2}{\edmins0}{\nofpages16}
{\nofwords4521}{\nofchars25773}{\*\company Dell Computer Corporation}{\nofcharsws31651}{\vern113}}\widowctrl\ftnbj\aenddoc\hyphcaps0\viewkind4\viewscale100 \fet0\sectd \linex0\sectdefaultcl {\*\pnseclvl1\pnucrm\pnstart1\pnindent720\pnhang{\pntxta .}}
{\*\pnseclvl2\pnucltr\pnstart1\pnindent720\pnhang{\pntxta .}}{\*\pnseclvl3\pndec\pnstart1\pnindent720\pnhang{\pntxta .}}{\*\pnseclvl4\pnlcltr\pnstart1\pnindent720\pnhang{\pntxta )}}{\*\pnseclvl5\pndec\pnstart1\pnindent720\pnhang{\pntxtb (}{\pntxta )}}
{\*\pnseclvl6\pnlcltr\pnstart1\pnindent720\pnhang{\pntxtb (}{\pntxta )}}{\*\pnseclvl7\pnlcrm\pnstart1\pnindent720\pnhang{\pntxtb (}{\pntxta )}}{\*\pnseclvl8\pnlcltr\pnstart1\pnindent720\pnhang{\pntxtb (}{\pntxta )}}{\*\pnseclvl9
\pnlcrm\pnstart1\pnindent720\pnhang{\pntxtb (}{\pntxta )}}\pard\plain \s16\nowidctlpar\adjustright \f17\cf1 {\b\f0\fs52\cf9 Chapter-2: Object Oriented Programming Concepts}{\f0\cf9 
\par 
\par You must have heard that some languages are procedural. Procedural programming because they consists of global variables and functions. Language such as COBOL (Common Business Oriented Language) is fully a p
rocedural language. Everything in COBOL is broken down into number of functions spread across different files. The same is true for the comparably younger procedural language C.  On the other hand, language such as Java is known as Object-Oriented languag
e. Everything around us falls to a category, i.e. a type. All we see around us are objects of those types. Objects consist of number of data elements and the operations defined on those data members. Both data and its operations for objects in an }{
\i\f0\cf9 Object-Oriented}{\f0\cf9  programming stay together as a capsule.
\par 
\par The success of the }{\i\f0\cf9 OO programming}{\f0\cf9  is entirely depends upon how good the designer and programmer in OO concepts. I would attempt to teach you the fundamentals of Object-Oriented programming such as Class, Objec
t, Message, Inheritance, Polymorphism, and Overriding briefly. It is very important to learn the OO concepts clearly. Organizations rapidly need to adopt business changes into its software products in order to keep competitive advantage. Only an OO langua
ge such as Java can support an organization towards achieving that goal and only by proper implementation of OO concepts.
\par 
\par "}{\b\i\f0\cf9 Object-Oriented Concepts}{\f0\cf9 " - lets you know the fundamentals of the Object-Oriented concepts such as }{\i\f0\cf9 Class}{\f0\cf9 , }{\i\f0\cf9 Object}{\f0\cf9 , }{\i\f0\cf9 Message}{\f0\cf9 , and }{\i\f0\cf9 Encapsulation}{\f0\cf9 .

\par 
\par "}{\b\i\f0\cf9 Inheritance}{\f0\cf9 " - this section tells you the concept of inheritance as an important feature of the }{\i\f0\cf9 Object-Oriented}{\f0\cf9  programming.
\par 
\par "}{\b\i\f0\cf9 Polymorphism}{\f0\cf9 " - section tells you about abstraction and providing a change mechanism using the abstraction along with overriding.
\par 
\par "}{\b\i\f0\cf9 Overloading}{\f0\cf9 " - talks about writing multiple functions with the same name but with different arguments.
\par 
\par }\pard \s16\nowidctlpar\outlinelevel0\adjustright {\b\f0\fs32\cf9 2.1\tab Preface}{\f0\cf9 
\par }\pard \s16\nowidctlpar\adjustright {\f0\cf9 
\par In this section, you are going to get a brief but clear idea about why one should consider Object-Oriented programming as an edge over procedural programming. Most of you might have worked in Object-Oriented programming such as C++. Those already know the
 OO concepts might skip this chapter. However, for others who are new to this concept or not very much familiar, might find it helpful.
\par 
\par You might have often heard about Pure Object-Oriented programming language. Important questions therefore, what is a pur
e Object-Oriented language and what is not pure?  You often heard C++ is a hybrid language and it is not a Pure Object-Oriented language. Is that true about Java? To tell you, Java is a pure Object-Oriented language and differs in some of the concepts wit
h C++. Therefore, the goal in this chapter is to discuss the OO concepts in the context of a "pure OO language" \endash 
 Java. In our discussion, you will find everything in Java is an object. Occasionally, I took the opportunity to discuss some major difference between C++ and Java, because most of the readers perhaps having some C++ background.
\par 
\par }\pard \s16\nowidctlpar\outlinelevel0\adjustright {\b\f0\fs32\cf9 2.1.1\tab What is a Class?}{\f0\cf9 
\par }\pard \s16\nowidctlpar\adjustright {\f0\cf9 
\par To understand the analogy of a class, we are going to consider a better example - \ldblquote cars\rdblquote . It is a physical entity or type. For example, all four-w
heel vehicles fitted with an Engine belong to a particular category called "Car". All two-wheel vehicles fitted with an engine are usually called "Motor Cycles". One can easily understand, at least one thing is common to them - they all belong to a partic
ular category or type, e.g. "Car" or "Motor Cycle". However, type like "Car" or \ldblquote motor cycle\rdblquote  does not describe your particular car or motor cycle. We might also say that the \ldblquote BMW\rdblquote 
 is a special type of car. You perhaps own a "BMW" car and that is gray color, year-2003 model, four doors, etc. Someone may have owned a "BMW" car with silver color, year-2002 model, and two doors.  You perhaps got some idea about what do I mean by 
\ldblquote BMW\rdblquote  and \ldblquote your particular gray, 2003, 4-door BMW car\rdblquote . What we are saying here is that the \ldblquote BMW\rdblquote  is a type of \ldblquote car\rdblquote 
. In software world, a type is known as a class. Therefore, \ldblquote BMW\rdblquote  can be considered as a class of \ldblquote Car\rdblquote .
\par 
\par Similarly, we often say, "}{\i\f0\cf9 penguins is a type of bird}{\f0\cf9 ". When \ldblquote }{\i\f0\cf9 bird}{\f0\cf9 \rdblquote  is the general type, penguins is the special type 
of bird. Knowingly or unknowingly, we somehow have the knowledge of a type.
\par 
\par A class is like a factory that is capable of producing instances. Attributes value of each of such instances varies. For example, a car factory produces new cars. More specifically, a BMW factory can produce new BMW cars of different colors and models.

\par 
\par Let us take one more example. Similar to the \ldblquote car\rdblquote  class, \ldblquote BankAccount\rdblquote  is again considered as a class. A \ldblquote BankAccount\rdblquote  factory can produce new bank account identified by an account
 number, name, address, and more attributes.
\par 
\par }\pard \s16\nowidctlpar\outlinelevel0\adjustright {\b\f0\fs32\cf9 2.1.2\tab What is an Object?}{\f0\cf9 
\par }\pard \s16\nowidctlpar\adjustright {\f0\cf9 
\par In order to understand about objects let us look at the illustration next. It explains that the factory at the middle is the \ldblquote Car\rdblquote  class from where all the new BMWs are produced.
\par 
\par The little squares inside the object spaces are indicative of different values of the attributes for the variety model of BMW car created by the factory. Examples of such attributes are the color of the car, number of doors, engine capacity, and so on. 

\par 
\par Following is the general syntax for creating objects (\ldblquote }{\i\f0\cf9 your individual car}{\f0\cf9 \rdblquote ) from the \ldblquote Car\rdblquote  factory, i.e. }{\i\f0\cf9 class}{\f0\cf9 .
\par 
\par }\pard \s16\nowidctlpar\outlinelevel0\adjustright {\f2\cf9   Car myCar = new Car();}{\f0\cf9 
\par }\pard \s16\nowidctlpar\adjustright {\f0\cf9 
\par In Java, a class name starts with a capital letter. However, there is no bar in naming the class with all small letters. In diagram shows six different cars are created from the BMW car factory.
\par 
\par Value of a particular attribute of \ldblquote your particular car\rdblquote  instance might change, if you repaint it with a different color. Therefore, the class that created it must have methods so t
hat the color once changed can be changed in the system too. Usually, there is always a }{\i\f0\cf9 setter}{\f0\cf9  and }{\i\f0\cf9 getter}{\f0\cf9  method for each particular }{\i\f0\cf9 attribute of the object}{\f0\cf9 
. For example, to change the color information of the car in the system the Car class might have getColor and setColor methods. Therefore, }{\f2\cf9 myCar}{\f0\cf9  needs to be initialized with appropriate attribute values shown next.
\par 
\par }\pard \s16\nowidctlpar\outlinelevel0\adjustright {\i\f0\cf9 Listing \endash  2.1: Object creation syntax}{\f0\cf9 
\par }\pard \s16\nowidctlpar\adjustright {\f0\cf9 
\par }{\f2\cf9   Car myCar = new car();
\par   myCar.setMake(\ldblquote BMW\rdblquote );
\par   myCar.setModel(\ldblquote M3\rdblquote );
\par   myCar.setColor(\ldblquote Gray\rdblquote );}{\f0\cf9 
\par 
\par Similarly, a BankAccount class is a representative of your bank account in a bank. Following is perhaps the simplest definition of it.
\par 
\par }\pard \s16\nowidctlpar\outlinelevel0\adjustright {\i\f0\cf9 Listing \endash  2.2: Simplest definition of a bank account class.}{\f0\cf9 
\par }\pard \s16\nowidctlpar\adjustright {\f0\cf9 
\par }{\f2\cf9 class BankAccount \{
\par   int ac_no;
\par   int balance;
\par   int getBalance() \{ return balance;\}
\par   void setBalance(int amout) \{ balance = amount;\}
\par   int getAccountNumber() \{return ac_no;\}
\par   void setAccountNumber(int accountNo) \{ ac_no = accountNo;\}
\par \}}{\f0\cf9 
\par 
\par }\pard \s16\nowidctlpar\outlinelevel0\adjustright {\b\f0\fs32\cf9 2.1.3. \tab What is a Message?}{\f0\cf9 
\par }\pard \s16\nowidctlpar\adjustright {\f0\cf9 
\par To understand the messages, let us take the example about how we communicate with each other. If you ask a little kid, \ldblquote What is your name\rdblquote 
? You expect to hear a name as the reply to your question. This is exactly happens to the objects of various classes. Objects communicate with each other by passing
 a message, called methods or functions. In software world, an object passes message to another object by way of calling each other\rquote s accessible methods called APIs. This way a task is ultimately performed for the system.
\par 
\par For example, you are interested to know the account balance for your bank account object myAccount. Another object that is responsible for querying the balance is actually calls myAccount\rquote s }{\f2\cf9 getBalance()}{\f0\cf9  method.
\par 
\par }\pard \s16\nowidctlpar\outlinelevel0\adjustright {\b\f0\fs32\cf9 2.2.\tab Inheritance}{\f0\cf9 
\par }\pard \s16\nowidctlpar\adjustright {\f0\cf9 
\par Inheritance means acquiring or sharing something from others.
 If there is a public library in your area, a lot of people goes there to pick up the same book that you have read and just returned. There are members, who might not get access to some of the library resources such as copy machines, while other members c
an access all resources of the library. Which member should be allowed to share what kind of resources from the library is decided by the library administrators.
\par 
\par Similarly, a piece of information that is personal to you are perhaps accessible (on asking) to your parents, friends and some relatives. However, you perhaps will not share the information to anyone else. If you are a class, it is up to you to decide who
 can have access to the piece of information and who not.
\par 
\par In software world, all we talk about is the information sharing. Therefore, to understand the analogy of inheritance, classes possibly allow access to some of its data members and functions to its children classes. Children classes are known as }{
\i\f0\cf9 derived classes}{\f0\cf9  that inherits accessible data members and functions from it\rquote s parent (}{\i\f0\cf9 super class}{\f0\cf9 ) and grant parents.
\par }{\i\f0\cf9 
\par }{\f0\cf9 There are several reasons, why we want to inherit something that is already existing in some class is discussed in the next few sections.
\par 
\par }\pard \s16\nowidctlpar\outlinelevel0\adjustright {\b\f0\fs32\cf9 2.2.1.\tab Reusing codes}{\f0\cf9 
\par }\pard \s16\nowidctlpar\adjustright {\f0\cf9 
\par Imagine that the books, copy machines, printers, telephones etc. in the library are not shared. The cost of purchasing them by the individual member is enormous and unbearable. This is 
exactly the reason why resources and information already available in one class (therefore its objects) must be shared by other classes interested to inherit from it. The code already written in a class to serve some purpose }{\i\f0\cf9 
must be reused at its maximum}{\f0\cf9 .
\par 
\par }\pard \s16\nowidctlpar\outlinelevel0\adjustright {\f0\cf9 To understand reusing, let us design two classes
\par }\pard \s16\nowidctlpar\adjustright {\f0\cf9 
\par Point \endash  that has two data members x and y to represent a point.
\par Circle \endash  is inherited from the Point class in order to reuse the already defined point (x,y).
\par 
\par }\pard \s16\nowidctlpar\outlinelevel0\adjustright {\f0\cf9 Following is how the two classes looks like.
\par }\pard \s16\nowidctlpar\adjustright {\f0\cf9 
\par }\pard \s16\nowidctlpar\outlinelevel0\adjustright {\i\f0\cf9 Listing \endash  2.5: Circle is inheriting members from its parent class Point.
\par }\pard \s16\nowidctlpar\adjustright {\i\f0\cf9 
\par }{\f2\cf9 //Point.java
\par class Point \{
\par   int x;
\par   int y;
\par   int getX() \{ return x;\}
\par   int getY() \{ return y;\}
\par   void setX(int newX) \{ x = newX;\};
\par   void setY(int newY) \{ y = newY;\}
\par \}
\par 
\par //Circle.java
\par class Circle }{\b\f2\cf9 extends Point}{\f2\cf9  \{
\par   int r;
\par   int getRadious() \{ return r;\}
\par   void setRadious(int newR) \{ r = newR;\}
\par   double getArea() \{ return 3.141*r*r;\}
\par }\pard \s16\nowidctlpar\outlinelevel0\adjustright {\b\f2\cf9   Point getCenter() \{ return (Point)this;\}
\par }\pard \s16\nowidctlpar\adjustright {\b\f2\cf9  }{\f2\cf9  int getDiameter() \{ return 2*r;\}
\par \}}{\f0\cf9 
\par 
\par }\pard \s16\nowidctlpar\outlinelevel0\adjustright {\b\f0\fs32\cf9 2.2.2.\tab Responding to the rapid business changes}{\f0\cf9 
\par }\pard \s16\nowidctlpar\adjustright {\f0\cf9 
\par Rapid changes in business practices is potentially an important reason as to why do we have to think of creating a new class with a changed definition of the previously defined functionality (data members and their
 operations). However, redefining the entire class may not be necessary, as the changes with respect to the previous definition of the same business entity is minimum. Therefore, it is perhaps good idea to inherit the members (both data and function membe
rs) and provide new definition for those operations in the new class that are changed. Changing the definition of a function in the derived class that was originally defined in its base class is known as overriding. 
\par 
\par Let us take an example of the FixedDepo
sit class. A class like this is used by a bank for presenting a deposit amount and calculating the maturity value after its maturity period. The way bank was calculating interest previously is now changed due to more competitive business practices and cha
n
ges in business practices in the global economy. This means the definition of calculating the interest is changed over a period. Therefore, the software division of the bank needs to update the software so that the system is capable of calculating maturit
y amount based on the redefined rules. Let us see how to inherit the DerivedFixedDeposit from previously defined FixedDeposit class and then redefine (override) its calculateMaturityValue() function. 
\par 
\par }{\i\f0\cf9 Listing \endash  2.6: The FixedDeposit class that has the older definition of calculating maturity amount.}{\f0\cf9 
\par 
\par }{\f2\cf9 class FixedDeposit \{
\par   int amountDeposited;
\par   int numberOfYears;
\par 
\par   int getAmoutDeposited() \{ return amoutDeposited;\}
\par   void setAmoutDeposited(int amount) \{amoutDeposited = amout;\}
\par   int getMaturtyPeriod() \{ return numberOfYears;\}
\par   void setMaturityPeriod(int years) \{ numberOfYears = years;\}
\par   int calculateMaturityValue() \{
\par     int interestRate;
\par     if (numberOfYears <= 4) \{
\par       interestRate = 4;
\par     \}else\{
\par       interestRate = 5;
\par     \}
\par     int interest = amountDeposited * (interestRate/100) * numberOfYears;
\par     return (amountDeposited + interest);
\par   \}
\par \}}{\f0\cf9 
\par 
\par Now let us inherit and redefine the calculateMaturityValue function in order to implement the changed definition.
\par 
\par }{\i\f0\cf9 Listing \endash  2.7: DerivedFixedDeposit class inherits previous functionality and redefines the maturity value.}{\f0\cf9 
\par 
\par }{\f2\cf9 class DerivedFixedDeposit extends FixedDeposit \{
\par   int calculateMaturityValue() \{
\par     int interestRate;
\par     if (numberOfYears <= 2) \{
\par       interestRate = 2;
\par     \}else if (numberOfYears <= 4) \{
\par       interestRate = 3;
\par     \}else \{
\par       interestRate = 4;
\par     \}
\par     int interest = amountDeposited * (interestRate/100) * numberOfYears;
\par     return (amountDeposited + interest);    
\par   \}
\par \}}{\f0\cf9 
\par 
\par If you observe the newly created DerivedFixedDeposit class carefully, you\rquote 
ll see that the interest is decided based on 2, 4 and >4 years duration and the rates applied are different. The new class has just one redefined calculateMaturityValue function. Rest is reused from the previous definition in the FixedDeposit class.

\par 
\par }\pard \s16\nowidctlpar\outlinelevel0\adjustright {\b\f0\fs32\cf9 2.2.3\tab Specializing}{\f0\cf9 
\par }\pard \s16\nowidctlpar\adjustright {\f0\cf9 
\par The general observation in the inheritance hierarchy is that the base classes are lighter and derived classes are heavier. The reason behind this is that new data and 
function members are added in the derived classes to make it useful in special purposes. Derived classes inherit members from base classes and then add new members.
\par 
\par }\pard \s16\nowidctlpar\outlinelevel0\adjustright {\b\f0\fs32\cf9 2.3.4.\tab How much is inherited?}{\f0\cf9 
\par }\pard \s16\nowidctlpar\adjustright {\f0\cf9 
\par We have started our discussion in the previous section with the }{\i\f0\cf9 private}{\f0\cf9 , }{\i\f0\cf9 protected}{\f0\cf9 
, and public access specifier for each data and function members of a class. Let us continue the discussion as to see exactly how you can control the resource access of your particular class to any one inherits from it. How much is i
nherited is depends on what members from the base classes are accessible by the external world.
\par 
\par }\pard \s16\nowidctlpar\outlinelevel0\adjustright {\b\f0\fs32\cf9 2.3.\tab Polymorphism}{\f0\cf9 
\par }\pard \s16\nowidctlpar\adjustright {\f0\cf9 
\par For a pure procedural language programmer this is perhaps a new idea. However, for a C++ or \lquote Small talk\rquote  programmer it is a known OO behavio
r. I would like to mention you again that the goodness of OO programming depends on good design of the classes. 
\par 
\par }\pard \s16\nowidctlpar\outlinelevel0\adjustright {\b\f0\fs32\cf9 2.3.1.\tab What is it?}{\f0\cf9 
\par }\pard \s16\nowidctlpar\adjustright {\f0\cf9 
\par The word polymorphism in OOP means performing different task at the runtime using the same function. Common functions are 
defined across classes that are in an inheritance hierarchy. Let me now take an example to have some understanding about this concept and then we\rquote 
ll have more discussions later. In our previous discussions in this chapter, we have mentioned about the \ldblquote }{\i\f0\cf9 shape}{\f0\cf9 \rdblquote 
 package that is consisting of multiple geometric shapes. There we have talked about class such as Point, Line, Triangle, and Polygon. Their inheritance hierarchy is presented again in the figure-1.10 with a little modification. In this section, we would
 demonstrate polymorphism behavior using these four classes. Let us look at the figure again. All of the classes in the hierarchy having a common function draw.
\par 
\par We are going to make the objects of these classes capable of drawing itself to the Graphics ob
ject passed as an argument to its draw method. Out goal is to draw different shapes by instantiating each class and calling its draw method. Method draw when called from an object of (let us say) Triangle the draw implemented in this class is called and n
ot the draw available and inherited from its parent class Line and Point. 
\par 
\par How do you test the behavior? Just create objects from the Line, Triangle, and Polygon classes, and then call their draw method. You\rquote ll see that the draw function available in the d
erived class is called at runtime and not the copy of the draw available in the base. Even if you create a Triangle object, assign to a Point object, and then call the draw method, still the draw from Triangle is called. This dynamic behavior is known as 
so-called  }{\i\f0\cf9 polymorphism}{\f0\cf9 
 behavior. Polymorphism behavior actually hides the draw method implemented in the base classes. For simplicity, you can put just a System.out console output statement without actually drawing the shape on the Graphics to see which ve
rsion of the draw is called from the objects. Obviously, later in this chapter, we\rquote ll demonstrate this behavior by actually painting the shapes on screen. 
\par 
\par }\pard \s16\nowidctlpar\outlinelevel0\adjustright {\b\f0\fs32\cf9 2.3.2.\tab Means of achieving polymorphism? }{\f0\cf9  
\par }\pard \s16\nowidctlpar\adjustright {\f0\cf9 
\par As a fundamental rule, you must have a common interface function declared in the base class from which all other classes are derived. There are various ways to implement the polymorphism behavior discussed in the next few sections with examples.
\par 
\par }\pard \s16\nowidctlpar\outlinelevel0\adjustright {\b\i\f0\fs28\cf9 2.3.2.1.\tab Overriding}{\f0\cf9  
\par }\pard \s16\nowidctlpar\adjustright {\f0\cf9 
\par I think, the best way to understand the polymorphism is to construct the above classes by actually painting the shapes in a GUI window as a test case. So, let us construct the classes shown in the listing-2.16.
\par 
\par }\pard \s16\nowidctlpar\outlinelevel0\adjustright {\i\f0\cf9 Listing \endash  2.17: Classes in shape package are implemented with a common draw method.
\par }\pard \s16\nowidctlpar\adjustright {\i\f0\cf9 
\par }{\f2\cf9 package shapes;
\par import java.awt.Graphics;
\par 
\par public class Point \{
\par   protected int x;
\par   protected int y;
\par   public int getX() \{ return x;\}
\par   public int getY() \{ return y;\}
\par   public void setX(int newX) \{ x = newX;\};
\par   public void setY(int newY) \{ y = newY;\}
\par 
\par   public void draw(Graphics g) \{
\par     g.fillRect(x, y, 2, 2); //point of 2 pixels width.
\par   \}
\par \}
\par 
\par package shapes;
\par import java.awt.Graphics;
\par public class Line extends Point \{
\par   protected int x2;
\par   protected int y2;
\par   public int getX2() \{ return x2;\}
\par   public void setX2(int newX2) \{ x2 =newX2;\}
\par   public int getY2() \{ return y2;\}
\par   public void setY2(int newY2) \{ y2 = newY2;\}
\par 
\par   public void draw(Graphics g) \{
\par     g.drawLine(x, y, x2, y2);
\par   \}
\par \}
\par 
\par package shapes;
\par import java.awt.Graphics;
\par public class Triangle extends Line \{
\par   protected int x3;
\par   protected int y3;
\par   public int getX3() \{ return x3;\}
\par   public void setX3(int newX3) \{ x3 = newX3;\}
\par   public int getY3() \{ return y3;\}
\par   public void setY3(int newY3) \{ y3 = newY3;\}
\par 
\par   public void draw(Graphics g) \{
\par     int xPts[] = \{x, x2, x3\};
\par     int yPts[] = \{y, y2, y3\};
\par     g.drawPolyline(xPts, yPts, 3);
\par   \}
\par \}
\par 
\par package shapes;
\par import java.awt.Graphics;
\par public class Polygon extends Triangle \{
\par   public void draw(Graphics g) \{
\par     int xPts[] = \{x, x2, x3\};
\par     int yPts[] = \{y, y2, y3\};
\par     g.drawPolygon(xPts, yPts, 3); //fills a polygon with 3 points.
\par   \}
\par \}
\par 
\par }{\f0\cf9 You must have noticed that the inherited classes have a common draw method. However, the implementation is different in each of the classes. What is new in these pieces of codes are that all of them has an }{\i\f0\cf9 import command}{\f0\cf9 
 in order to import the Graphics class available in the Java AWT library. Rest parts of the code are self-explanatory. When a derived class implements an inherited base function with the identical method signature, it is called }{\i\f0\cf9 
function overriding}{\f0\cf9 . It is therefore an essential ingredient of polymorphism.
\par 
\par }\pard \s16\nowidctlpar\outlinelevel0\adjustright {\b\i\f0\fs28\cf9 2.3.2.1.1.\tab An Example
\par }\pard \s16\nowidctlpar\adjustright {\b\i\f0\fs28\cf9 
\par }{\f0\cf9 To run objects from above classes we must have to create a test program. Let us now create a test application program called Poly shown in the listing-2.17.
\par 
\par }{\i\f0\cf9 Listing \endash  2.18: Shapes class is constructed for testing polymorphism in the Point, Line, Triangle, and Polygon objects.
\par 
\par }{\f2\cf9 package shapes;
\par import java.awt.*;
\par import javax.swing.*;
\par class Poly extends JFrame \{
\par   public static void main(String[] args) \{
\par     Poly polyFrame = new Poly();
\par     polyFrame.setSize(400,300);
\par     polyFrame.setBackground(Color.white);
\par 
\par     Triangle t = new Triangle();
\par     t.setX(200);
\par     t.setY(30);
\par     t.setX2(30);
\par     t.setY2(270);
\par     t.setX3(370);
\par     t.setY3(270);
\par     polyFrame.setShape(t);
\par     polyFrame.setVisible(true);
\par   \}
\par 
\par   private Point shape;
\par   public void setShape(Point p) \{
\par     shape = p;
\par   \}
\par 
\par   public void paint(Graphics g) \{
\par     g.setColor(Color.blue);
\par     g.clearRect(0, 0, getWidth(), getHeight());
\par     shape.draw(g);
\par   \}
\par \}
\par 
\par }{\f0\cf9 The above little code is the Poly class derived from a Java swing class JFrame, so that we can paint the shapes using its Graphics object. We have already discussed in chapter-I about how we have painted \ldblquote }{\f0\ul\cf9 Hi There!}{
\f0\cf9 \rdblquote  in the applet. Because, JFrame belong to Swing package, we have imported \ldblquote }{\f2\cf9 javax.swing.*}{\f0\cf9 \rdblquote , i.e. all, in addition to all from the AWT package \ldblquote }{\f2\cf9 java.awt}{\f0\cf9 \rdblquote . 

\par 
\par In the main method, we have created an object out of }{\f2\cf9 Triangle}{\f0\cf9  class and passed as the base type Point in the }{\f2\cf9 setShape}{\f0\cf9  method. In the draw(}{\f2\cf9 Graphics}{\f0\cf9 ) method we get the }{\f2\cf9 java.awt.Graphics }
{\f0\cf9 class object needed for painting the particular shape. When you run this Poly class, you\rquote ll see }{\i\f0\cf9 a Triangle is drawn and not a Point or the Line.}{\f0\cf9 
  Just to remind you that the Triangle class has inherited draw methods from Line as well as from the Point class. Therefore, the Triangle object \ldblquote }{\f2\cf9 t}{\f0\cf9 \rdblquote 
 has two more versions of draw method in addition to its own draw method. The conclusion is that although we have called the draw method through its base class object Point, the runtime actually called the draw method fr
om the Triangle and not the version of draw available in the Point object. Polymorphism hides the inherited base methods if they are redefined in the derived.
\par 
\par }\pard \s16\nowidctlpar\outlinelevel0\adjustright {\b\i\f0\fs28\cf9 2.3.2.1.2.\tab Automatic type casting (up casting)
\par }\pard \s16\nowidctlpar\adjustright {\b\i\f0\fs28\cf9 
\par }{\f0\cf9 One interesting thing you might have observed is that the }{\f2\cf9 setShape}{\f0\cf9  method in the }{\f2\cf9 Poly}{\f0\cf9 
 class. The argument to this method is the base type Point. However, we have created an instance of the Triangle and passed that as an argument. Derived objects are automatically type casted to its base type called }{\i\f0\cf9 up casting}{\f0\cf9 
. This is why the compiler will never complain.
\par 
\par However, the reverse (down casting) is not possible. If you pass a base class object when the argument is a derived class, the compiler will not compile your code. However, an object can be }{\i\f0\cf9 down casted}{\f0\cf9 
 to a derived class by verifying if it is inherited from the base, using the Java\rquote s \ldblquote }{\f2\cf9 instanceof}{\f0\cf9 \rdblquote  operator.
\par 
\par }\pard \s16\nowidctlpar\outlinelevel0\adjustright {\b\f0\fs28\cf9 2.3.2.2.\tab Abstraction
\par }\pard \s16\nowidctlpar\adjustright {\b\f0\fs28\cf9 
\par }{\f0\cf9 Abstraction is a design pattern used for enforcing the above-mentioned common behavior through the draw method. Java provides 
the abstract keyword for this purpose. In order to enforce the common behavior a base class might just declare the function and let the derived classes implement the interface functions as the common behavior for all classes in the inheritance hierarchy. 
Let us therefore, think a redesigned geometric class hierarchy shown in the figure-2.11.
\par 
\par }\pard \s16\nowidctlpar\outlinelevel0\adjustright {\i\f0\cf9 Figure \endash  2.11: Enforcing common behavior through an abstract base class.
\par }\pard \s16\nowidctlpar\adjustright {\i\f0\cf9 
\par }{\f0\cf9 All geometric classes are derived from a common base class called Shape that one abstract function draw. Derived classes simply inherit from the Shape class and redefine the draw function to do their own specialized task.
\par 
\par Following is the syntax for decla
ring an abstract base class Shape from which rest of the classes are derived and are forced to implement the draw behavior. The Shape class is empty apart from declaring the draw method. It just provides the common draw interface all shapes.
\par 
\par }\pard \s16\nowidctlpar\outlinelevel0\adjustright {\i\f0\cf9 Listing \endash  2.19: An abstract base class Shape
\par }\pard \s16\nowidctlpar\adjustright {\i\f0\cf9 
\par }{\f2\cf9 package shapes;
\par import java.awt.Graphics;
\par }{\b\f2\cf9 abstract}{\f2\cf9  public class Shape \{
\par   public }{\b\f2\cf9 abstract}{\f2\cf9  void draw(Graphics);
\par \}
\par 
\par }{\f0\cf9 An abstract method has only the signature without the impl
ementation. In a base class, there can be any number of common functions declared to enforce the particular behavior in the derivation hierarchy. Following is the modified implementation of the base class Point that it is derived from the Shape class. Imp
lementation for other classes such as Line, Triangle, Circle, and Polygon remains the same.
\par 
\par }\pard \s16\nowidctlpar\outlinelevel0\adjustright {\i\f0\cf9 Listing \endash  2.20: All geometric shapes are now a common type called Shape.
\par }\pard \s16\nowidctlpar\adjustright {\i\f0\cf9 
\par }{\f2\cf9 package shapes;
\par import java.awt.Graphics;
\par public class Point }{\b\f2\cf9 extends Shape}{\f2\cf9  \{
\par   protected int x;
\par   protected int y;
\par   public int getX() \{ return x;\}
\par   public int getY() \{ return y;\}
\par   public void setX(int newX) \{ x = newX;\};
\par   public void setY(int newY) \{ y = newY;\}
\par 
\par   public void draw(Graphics g) \{
\par     g.fillRect(x, y, 2, 2); 
\par   \}
\par \}
\par 
\par //Implementation for all other shape classes remains the same.
\par public class Triangle extends Line \{
\par   ....
\par \}
\par ....
\par 
\par }{\f0\cf9 An abstract class can not be used for creating instances. If at least one function declared as abstract, then the class signature must be dec
lared as abstract too. This is why we have declared the Shape class with an abstract keyword in its class declaration. A derived class object can be created and assigned to the abstract base type in order to call the common function draw. You might do a l
ittle change in the Poly class to accept the Shape class as the common type of all shapes, instead of the previously used Point parameter in the setShape method.
\par 
\par }{\i\f0\cf9 Listing \endash  2.21: External class Poly has created instances of the Shape classes for polymorphism testing.
\par 
\par }{\f2\cf9 package shapes;
\par import java.awt.*;
\par import javax.swing.*;
\par class Poly extends JFrame \{
\par 
\par   public static void main(String[] args) \{
\par     ....      ....
\par   \}
\par 
\par   private }{\b\f2\cf9 Shape shape;
\par }{\f2\cf9 
\par   public void }{\b\f2\cf9 setShape(Shape shape)}{\f2\cf9  \{
\par     this.shape = shape;
\par   \}
\par 
\par   public void paint(Graphics g) \{
\par     g.setColor(Color.blue);
\par     g.clearRect(0, 0, getWidth(), getHeight());
\par     shape.draw(g);
\par   \}
\par \}
\par 
\par }\pard \s16\nowidctlpar\outlinelevel0\adjustright {\b\f0\fs28\cf9 2.3.2.3.\tab Interface
\par }\pard \s16\nowidctlpar\adjustright {\b\f0\fs28\cf9 
\par }{\f0\cf9 Java supports interfaces as types. There is the \ldblquote interface\rdblquote  keyword for creating interfaces. Like the \ldblquote class\rdblquote  keyword if \ldblquote interface\rdblquote 
 is added before a type, the type is called an interface. In the abstraction section, you have seen that the Shape class is declared as an abstract class because it has one abstract m
ethod draw. Following is the signature of interface declaration. Let us redefine the Shape as an interface instead of an abstract class declared earlier.
\par 
\par }\pard \s16\nowidctlpar\outlinelevel0\adjustright {\i\f0\cf9 Listing \endash  2.22: Shape class is replaced with the Shape interface.
\par }\pard \s16\nowidctlpar\adjustright {\i\f0\cf9 
\par }{\f2\cf9 package shapes;
\par public }{\b\f2\cf9 interface}{\f2\cf9  Shape \{
\par   public void draw(Graphics g);
\par \}
\par 
\par }{\f0\cf9 You can see that there are some syntax difference between the Shape}{\i\f0\cf9  }{\f0\cf9 class defined earlier and the }{\i\f0\cf9 Shape interface}{\f0\cf9  declared here. The interface is declared with \ldblquote interface\rdblquote 
 keyword. However, the draw(Graphics g) method is not prefixed with any special keyword. An interface is as if a }{\i\f0\cf9 prototype of a type)}{\f0\cf9 
  (like the .h file for a .cpp file in C++ code). Interface once declared, can be implemented by any class.
\par 
\par Now, we\rquote ll see how the Shape interface can be implemented to enforce the draw behavior for all the special shape classes. Special classes must implement the Shape interface, so that the objects of these classes can be used as a }{\i\f0\cf9 
common type, i.e. Shape}{\f0\cf9 . When trying to achieve polymorphism through the implementati
on of interface instead of abstract class, there is hardly any code change. Apart from above little change shown in listing-2.21, the Point class has to implement the Shape behavior that is inherited by rest of the shapes.
\par 
\par }\pard \s16\nowidctlpar\outlinelevel0\adjustright {\i\f0\cf9 Listing 2.23: All geometric classes implement the common interface Shape
\par }\pard \s16\nowidctlpar\adjustright {\i\f0\cf9 
\par }{\f2\cf9 package shapes;
\par import java.awt.Graphics;
\par public class Point }{\b\f2\cf9 implements Shape}{\f2\cf9  \{
\par   ....    ....
\par   public void draw(Graphics g) \{
\par     g.fillRect(x, y, 2, 2); 
\par   \}
\par \}
\par 
\par }{\f0\cf9 //Implementation for all other classes remains the same.
\par Implementation for the test class Poly remains same and you can go ahead to compile and then run it for testing.
\par 
\par }\pard \s16\nowidctlpar\outlinelevel0\adjustright {\b\f0\fs32\cf9 2.3.2.4.\tab Difference between abstract class and an interface type
\par }\pard \s16\nowidctlpar\adjustright {\b\f0\fs32\cf9 
\par }{\f0\cf9 During implementing
 polymorphism behavior using abstract classes and interfaces in the last two sections, you have seen very little code changes. Fundamentally, both abstract base class and an interface enforce a common behavior by providing a type for all the objects in th
e hierarchy. However, following are some fundamental differences the two approaches mentioned next.
\par 
\par }{\i\f0\cf9 First}{\f0\cf9  - An abstract class can have }{\i\f0\cf9 defined}{\f0\cf9  and }{\i\f0\cf9 undefined}{\f0\cf9  methods (abstract methods). However, an interface just declares the method signature, but never def
ines them. In fact, an interface in Java can not provide implementation for a method.
\par 
\par }{\i\f0\cf9 Second}{\f0\cf9  - Unlike C++, Java does not support multiple inheritance. Therefore, you can not have a class to show multiple abstract behaviors. What it means is that you can n
ot create a class by inheriting from multiple abstract classes (pure OO feature). However, a class can implement multiple interfaces. Therefore, a class gets added advantage that it can behave as multiple types.
\par 
\par }{\i\f0\cf9 Third}{\f0\cf9  \endash  Interface allows a development grou
p to design the specification without knowing the implementation at the time of its design. Therefore, a vendor can implement the interfaces to any class name they preferred at a later point of time. Because, the implementation is vendor dependent, interf
aces allows the vendors an opportunity to have improved implementation with their own way.
\par 
\par }\pard \s16\nowidctlpar\outlinelevel0\adjustright {\b\f0\fs32\cf9 2.4.\tab Function Overloading
\par }\pard \s16\nowidctlpar\adjustright {\b\f0\fs32\cf9 
\par }{\f0\cf9 Function overloading is a common phenomenon for all Object-Oriented language. There is no exception in Java too. In a Java class, you can 
have multiple version of the same function. Just to let you always remember that function overriding discussed earlier in polymorphism is different from function overloading. As a definition, I would say that there could be different versions of the same 
function name with difference in their arguments with respect to the order and type. 
\par 
\par }\pard \s16\nowidctlpar\outlinelevel0\adjustright {\f0\cf9 Following is an example of overloaded sum methods in a Math class.
\par }\pard \s16\nowidctlpar\adjustright {\f0\cf9 
\par }\pard \s16\nowidctlpar\outlinelevel0\adjustright {\i\f0\cf9 Listing 2.24: Overloading of sum function.
\par }\pard \s16\nowidctlpar\adjustright {\i\f0\cf9 
\par }{\f2\cf9 package math;
\par public class Math \{
\par   public }{\b\f2\cf9 double sum(double i, int j) }{\f2\cf9 \{ 
\par     double local_j = (double) j;
\par     return (i + local_j);
\par   \}
\par 
\par   protected }{\b\f2\cf9 double sum(double i, double j) }{\f2\cf9 \{ return (i + j);\}
\par   private }{\b\f2\cf9 double sum(int i, double j, double k) }{\f2\cf9 \{ 
\par     double local_i = (double) i;
\par     return local_i + j + k;
\par   \}
\par   ....   ....
\par \}
\par 
\par }{\f0\cf9 The Math class allows the application to use its instance for summing of two double types as well as mixed types.
\par 
\par }\pard \s16\nowidctlpar\outlinelevel0\adjustright {\b\f0\fs32\cf9 2.4.1.\tab Rules for function overloading
\par }\pard \s16\nowidctlpar\adjustright {\b\f0\fs32\cf9 
\par }{\f0\cf9 Looking at the above-mentioned Math class, we have the following conclusions. 
\par \tab a. Functions name must be identical.
\par \tab b. Number of arguments might vary.
\par \tab c. The order of argument must not be same when using the same number and type of arguments.
\par \tab d. Function return type must be same.
\par \tab e. The access keyword }{\i\f0\cf9 public}{\f0\cf9 , }{\i\f0\cf9 protected}{\f0\cf9 , and }{\i\f0\cf9 private}{\f0\cf9  can be same or different.
\par 
\par Any exception to the above-mentioned rules, compiler will give errors thinking that you are declaring another function with the same name.
\par 
\par }\pard \s16\nowidctlpar\outlinelevel0\adjustright {\b\f0\fs32\cf9 2.4.2.\tab Why to overload?
\par }\pard \s16\nowidctlpar\adjustright {\b\f0\fs32\cf9 
\par }{\f0\cf9 It is often necessary to overload lot of functions that might ta
ke multiple parameters. In the Math example, you have seen that the return type for all the three functions is double. At the same time, the number of arguments are not same, ether two or three. However, the function that has two parameters the order of a
r
gument types is different. To sum two double values we can call the sum method. When summing one double and one integer value still we can call the sum method. Which function is going to be called is decided at runtime by function name, type, and number o
f arguments that are passed.
\par 
\par }\pard \s16\nowidctlpar\outlinelevel0\adjustright {\i\f0\cf9 Listing - 2.25: Example code for testing function overloading.
\par }\pard \s16\nowidctlpar\adjustright {\i\f0\cf9 
\par }{\f2\cf9 class MathTest \{
\par   public static void main(String[] args) \{
\par     Math math = new Math();
\par     //sum two double values
\par     System.out.println(\ldblquote sum doubles: \ldblquote  + math.sum(10.90 + 15.50));
\par     //sum one double with one integer
\par     System.out.println(\ldblquote sum double and int: \ldblquote  + math.sum(10.90 + 50));
\par     ....    ....
\par   \}
\par \}
\par 
\par }{\f0\cf9 The example above tests the overloaded sum() functions. You might put a console output stateme
nt to see which overloaded method is called during execution. The advantage of overloading is that we could able to use the same function name for summing numbers of various types. This helps in simplifying programming for application developers.
\par }\pard \s16\li540\nowidctlpar\adjustright {\f0\cf9 
\par }{\cf9 
\par }\pard\plain \li540\widctlpar\adjustright \fs20\cgrid {\f17\fs24\cf9\cgrid0 
\par }\pard \widctlpar\adjustright {\f17\fs24\cf9\cgrid0 
\par 
\par }}