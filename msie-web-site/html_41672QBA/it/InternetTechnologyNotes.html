<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<title>Internet Technology Notes</title>
<meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1" />
<link href="../css/topnav.css" rel="stylesheet" type="text/css" />
</head>

<body>
<div id="masthead">
  <h1 class="style1" id="siteName">Internet Technology Notes </h1>
  <div id="globalNav"> 
  	<a href="../index.html">Home </a> | <a href="../Courses.html">Courses</a> | <a href="../Assignments.html">Assignments</a> | <a href="../CurrentProjects.html">Projects</a> 
  </div>
</div>
<div id="content">
      <h2 id="pageName">&nbsp;</h2>
      <div class="feature"> 
	  	<img src="../images/niagarafalls.jpg" alt="" width="300" height="203" />
          <h3>Notes</h3>
          <p>I propose to make my basic course notes right here! By the way, the interesting item is Niagara Falls. </p>
          <p>&nbsp; </p>
          <p>&nbsp;</p>
          <p>&nbsp;</p>
  </div>
      <div class="story">
        <h3>&nbsp;</h3>
        <h2><a name="TOP" id="TOP"></a>My Notes </h2>
        <h3>&nbsp;</h3>
        <h4>host - DNS lookup utility</h4>
        <ul>
          <li>
            <h4> host smtp.hotpop.com </h4>
          </li>
          <li>
            <h4>host -r name</h4>
          </li>
          <li>
            <h4>host -l mit.edu</h4>
          </li>
        </ul>
        <h4>traceroute</h4>
        <h4>nmap</h4>
        <h4>wget</h4>
        <h4>nc</h4>
        <h4>dig - DNS lookup utility </h4>
        <h4> telnet pop.hotpop.com 110 <br />
        tcpdump</h4>
        <h4>netstat</h4>
        <h4>ifconfig</h4>
        <h4>tethereal </h4>
        <h4>snort, tripwire, ethereal </h4>
        <h4>www.whois.net; domain details lookup</h4>
        <h4>www.arin.net</h4>
        <h4>&nbsp;</h4>
        <h4>port forwarding?</h4>
        <h4>domains?</h4>
        <h4>how do I register my own domain - what does this mean in practice? </h4>
        <p>md5 - checksum</p>
        <p>md5sum, sha1sum </p>
        <p>pgp - public/private key key</p>
        <p>gpg - privact guard</p>
        <p>.sum, .asc - what are these? cryptographic identifier.</p>
        <p>Pay to be on a DNS server?</p>
        <p>What is a zone? Zone and domain are interchangeable.</p>
        <p>play with cgi cookies....</p>
        <p>openSSH tunnels X11 protocol, try ssh -X.</p>
        <p>dns spoofing?</p>
        <p>verisign, register a domain.   </p>
        <p>routed - RIP</p>
        <p>netstat -rn (routing info).</p>
        <p>netstat -l (open ports).</p>
        <h2>Subnet masks </h2>
        An IP address by itself is a unique identifier, but it doesn't give much information besides that.&nbsp; A more important piece of information, at least as far as your computer is concerned, is which machines are local and which are not.&nbsp; This is because IP is layered on top of lower-level protocols, like ethernet, that only understand local addresses.&nbsp; See <a href="http://devney.net/essays/ethernet-intro.html">ethernet </a> for more information.
        <p>The computer uses a subnet mask to determine what's local and what's not.&nbsp; All a subnet mask is, is a listing of which addresses are local.&nbsp;"Local" in this case means "near me". Anything that's not local goes to the default gateway, which is still a local address but knows where to send non-local packets. </p>
        <p>A subnet mask, at its heart, looks like this: <br />
  11111111.11111111.11111111.00000000 <br />
  That's more commonly represented as <br />
  255.255.255.0 <br />
  which is a basic class C subnet mask.&nbsp; What this tells the computer is that anything with the first three octets the same is local. </p>
        <p>This is an example of a classful subnet mask, which is hardly ever used any more.&nbsp; In fact, the class C is the only one you can ever expect to see in real life.&nbsp; For reference, here are the standard classes, though you can safely ignore them. <br />
            <br />
        </p>
        <table cellspacing="2" cellpadding="2">
          <tr>
            <td>Class </td>
            <td>Range </td>
            <td>Subnet Mask </td>
          </tr>
          <tr>
            <td>Class A </td>
            <td>3.0.0.0 to 126.255.255.255 </td>
            <td>255.0.0.0 </td>
          </tr>
          <tr>
            <td>Class B </td>
            <td>128.0.0.0 to 191.255.255.255 </td>
            <td>255.255.0.0 </td>
          </tr>
          <tr>
            <td>Class C </td>
            <td>192.0.0.0 to 223.255.255.255 </td>
            <td>255.255.255.0 </td>
          </tr>
          <tr>
            <td>Multicast </td>
            <td>224.0.0.0 to 255.255.255.0 </td>
            <td>N/A </td>
          </tr>
          <tr>
            <td></td>
            <td></td>
            <td></td>
          </tr>
        </table>
        <p>But all that is history.&nbsp; These days it's only used by <a href="http://www.iana.org">IANA </a> and <a href="http://www.arin.net">ARIN </a> and their <a href="http://www.ripe.net">affiliates </a> to allocate IP addresses.&nbsp; These days we use CIDR, or Classless Inter-Domain Routing, for the real work. <br />
        </p>
        <h2>CIDR </h2>
        Looking at the subnet mask above, you'll notice it's broken up into 2 sections: The first is all 1s and the second is all 0s.&nbsp; (You might also notice that it's broken up into 4 octets, but that's unimportant.)&nbsp; Those are just place holders, really; the 1s stand for fixed numbers and the 0s are variable.&nbsp; Thus, the class C subnet mask above means "The first 3 octets have to be the same, but the last octet is freestyle."
        <p>If you change the boundary between 1s and 0s, also known as the "bit boundary," to get another subnet mask, you get more or fewer IPs per subnet.&nbsp; For example, the subnet mask 11111111.11111111.11111110.00000000 (Also known as 255.255.254.0 ) translates to 512 IP addresses, or 2 class Cs.&nbsp; Why, you ask?&nbsp; Because the only thing that's changed is that you now have another digit to freestyle with.&nbsp; That means twice the previous number. </p>
        <p>This scales all the way up, and all the way down.&nbsp; You can have a subnet mask of 11111111.11100000.00000000.00000000 ( 255.224.0.0 ), or 32 class B blocks.&nbsp; A subnet mask of 11111111.11111111.11111111.11111100 ( 255.255.255.252 ) is very common for point-to-point links, such as T1/E1 lines, etc. <br />
        </p>
        <h2>Reserved addresses (or, what constitutes a subnet) </h2>
        If you've been figuring these for yourself instead of just reading along and nodding, then you noticed something wrong with that last example.&nbsp; A point to point link only has 2 IPs, right?&nbsp; One at each end.&nbsp; So why do we need a subnet mask of 255.255.255.252?&nbsp; That leaves 4 IPs.
        <p>Only two of those IPs are useable.&nbsp; The first IP address is called the "network number."&nbsp; It defines the starting point of the network.&nbsp; You can think of it as a name for your subnet.&nbsp; The last IP address is the broadcast address.&nbsp; Any packets sent to that address will be broadcast to all machines on the subnet.&nbsp; ( *Note: Security risk!&nbsp; Think DoS. ) </p>
        <p>So your subnet mask for a hypothetical T1 is going to be 255.255.255.252.&nbsp; Let's work this out. </p>
        <p>10.2.3.0 255.255.255.252 - Network number <br />
  10.2.3.1 255.255.255.252 - One end of the T1 <br />
  10.2.3.2 255.255.255.252 - Other end of the T1 <br />
  10.2.3.3 255.255.255.252 - Broadcast address <br />
        </p>
        <h2>Bitmasks </h2>
        That's clumsy to write, though.&nbsp; Yes, writing 255.255.255.252 is a lot easier than writing 11111111.11111111.11111111.11111100, but it's still pretty long, and hard to talk about.&nbsp; So we have bitmasks, which is a convenient shorthand for subnet masks.&nbsp; These are so simple -- just count the 1s.&nbsp; In the last example, there's 30 1 s and 2 0 s.&nbsp; So our subnet could be written shorthand as 10.2.3.0/30 .&nbsp; Much shorter, and once you get used to it, a much better explanation.
        <p>You'll also see some common bitmasks: /24 is a class C, /16 is a class B, etc.&nbsp; But remember the classes, too, are just shorthand -- almost nobody really uses them.&nbsp; Just for practice, see if you can figure out the subnet mask (binary and decimal) for a /13 bitmask. <br />
        </p>
        <h2>Some more reserved addresses </h2>
        <p><br />
  Now that you understand the theory, there's a few more numbers to remember just so you seem uberleet.&nbsp; Not all IP addresses (0.0.0.0 - 255.255.255.255) are available -- some are reserved. </p>
        <p>0.0.0.0/8 </p>
        <table>
          <tr>
            <td>Bitmask </td>
            <td>Reserved for </td>
          </tr>
          <tr>
            <td>0.0.0.0/8 </td>
            <td>Nobody gets to use this. </td>
          </tr>
          <tr>
            <td>1.0.0.0/7 </td>
            <td>IANA </td>
          </tr>
          <tr>
            <td>10.0.0.0/8 </td>
            <td>RFC1918 - See below </td>
          </tr>
          <tr>
            <td>127.0.0.0/8 </td>
            <td>Localhost -- waste of a class A, no? </td>
          </tr>
          <tr>
            <td>172.16.0.0/12 </td>
            <td>RFC1918 - See below </td>
          </tr>
          <tr>
            <td>192.168.0.0/16 </td>
            <td>RFC1918 - See below </td>
          </tr>
          <tr>
            <td>224.0.0.0/12 </td>
            <td>Multicast </td>
          </tr>
        </table>
        <h3>RFC1918 </h3>
        Since there are only a limited number of IP addresses available (4294967296), some of them can be reused in certain circumstances.&nbsp; In general, if your network is not going to touch the internet at large, you should be using these "unrouteable" addresses.&nbsp; If your network is only going to touch the internet in a few places, you might want to use these anyway, and consider NAT (Network Address Translation) for your public interface.
        <p>RFC 1918 is the official document that outlines and designates these segments, some in each class range since it predates CIDR. </p>
        <h2> Subnetting, Bit by Bit </h2>
        <h3>A. Binary arithmetic </h3>
        You may have heard that computers represent all numbers as "bits", or "zeros and ones." It would be more fair to say that computers work primarily with groups of eight 0's or 1's, called bytes. In practice, most desktop PC's work with clumps of four bytes at a time, or 32 bits. That's why 80386 through Pentium IV processors are called 32-bit processors. [Athough Pentium class processors have some 64-bit attributes such as a 64-bit external memory bus,they still do most operations as 32-bit operations.]
        <p>Now, think back to first grade math, when the teacher was describing the decimal numbering system. As it happens, it's called "decimal" (the root of the word is from Latin <em>decima </em>, a tenth part or tithe) because it's a numbering system that uses ten numbers: the numbers zero through nine. If you need to represent a number larger than nine, you have to start adding additional digits; then the teacher described the ones place, the tens place, the hundreds place, etc. For example, the number 45678 has a four in the "ten thousands" place, a five in the "thousands" place, a six in the "hundreds" place, a seven in the "tens" place, and a 8 in the "ones" place: </p>
        <table>
          <tr>
            <td>Ten Thousands </td>
            <td>Thousands </td>
            <td>Hundreds </td>
            <td>Tens </td>
            <td>Ones </td>
          </tr>
          <tr>
            <td>4 </td>
            <td>5 </td>
            <td>6 </td>
            <td>7 </td>
            <td>8 </td>
          </tr>
        </table>
        Since computers work in binary, and only have "0" and "1" to work with, they have to start new digits ("binary places", not "decimal places") as soon as they get past the number one! In decimal, the "decimal places" were all powers of ten: <br />
10 0 =1, <br />
10 1 =10, <br />
10 2 =100, <br />
10 3 =1000, etc. <br />
In binary, the "binary places" follow powers of two: <br />
2 0 =1 (1 binary), <br />
2 1 =2 (10 binary), <br />
2 2 =4 (100 binary), <br />
2 3 =8 (1000 binary), <br />
2 4 =16 (10000 binary), <br />
2 5 =32 (100000 binary), <br />
2 6 =64 (1000000 binary), <br />
2 7 =128 (10000000 binary), <br />
2 8 =256 (100000000 binary), etc. <br />
<br />
The number 45678 is represented in binary as follows:
<table>
  <tr>
    <td>(Binary Places, expressed as Decimal:) </td>
    <td>32768 </td>
    <td>16384 </td>
    <td>8192 </td>
    <td>4096 </td>
    <td>2048 </td>
    <td>1024 </td>
    <td>512 </td>
    <td>256 </td>
    <td>128 </td>
    <td>64 </td>
    <td>32 </td>
    <td>16 </td>
    <td>8 </td>
    <td>4 </td>
    <td>2 </td>
    <td>1 </td>
  </tr>
  <tr>
    <td></td>
    <td>1 </td>
    <td>0 </td>
    <td>1 </td>
    <td>1 </td>
    <td>0 </td>
    <td>0 </td>
    <td>1 </td>
    <td>0 </td>
    <td>0 </td>
    <td>1 </td>
    <td>1 </td>
    <td>0 </td>
    <td>1 </td>
    <td>1 </td>
    <td>1 </td>
    <td>0 </td>
  </tr>
</table>
(Add up the columns where you find ones: 32768 plus 8192 plus 4096 plus 512 plus 64 plus 32 plus 8 plus 4 plus 2 equals 45678!) <br />
Counting to Forty:
<table>
  <tr>Decimal Binary Decimal Binary Decimal Binary Decimal Binary </tr>
  <tr>
    <td align="right">1 </td>
    <td align="right">1 </td>
    <td align="right">11 </td>
    <td align="right">1011 </td>
    <td align="right">21 </td>
    <td align="right">10101 </td>
    <td align="right">31 </td>
    <td align="right">11111 </td>
  </tr>
  <tr>
    <td align="right">2 </td>
    <td align="right">10 </td>
    <td align="right">12 </td>
    <td align="right">1100 </td>
    <td align="right">22 </td>
    <td align="right">10110 </td>
    <td align="right">32 </td>
    <td align="right">100000 </td>
  </tr>
  <tr>
    <td align="right">3 </td>
    <td align="right">11 </td>
    <td align="right">13 </td>
    <td align="right">1101 </td>
    <td align="right">23 </td>
    <td align="right">10111 </td>
    <td align="right">33 </td>
    <td align="right">100001 </td>
  </tr>
  <tr>
    <td align="right">4 </td>
    <td align="right">100 </td>
    <td align="right">14 </td>
    <td align="right">1110 </td>
    <td align="right">24 </td>
    <td align="right">11000 </td>
    <td align="right">34 </td>
    <td align="right">100010 </td>
  </tr>
  <tr>
    <td align="right">5 </td>
    <td align="right">101 </td>
    <td align="right">15 </td>
    <td align="right">1111 </td>
    <td align="right">25 </td>
    <td align="right">11001 </td>
    <td align="right">35 </td>
    <td align="right">100011 </td>
  </tr>
  <tr>
    <td align="right">6 </td>
    <td align="right">110 </td>
    <td align="right">16 </td>
    <td align="right">10000 </td>
    <td align="right">26 </td>
    <td align="right">11010 </td>
    <td align="right">36 </td>
    <td align="right">100100 </td>
  </tr>
  <tr>
    <td align="right">7 </td>
    <td align="right">111 </td>
    <td align="right">17 </td>
    <td align="right">10001 </td>
    <td align="right">27 </td>
    <td align="right">11011 </td>
    <td align="right">37 </td>
    <td align="right">100101 </td>
  </tr>
  <tr>
    <td align="right">8 </td>
    <td align="right">1000 </td>
    <td align="right">18 </td>
    <td align="right">10010 </td>
    <td align="right">28 </td>
    <td align="right">11100 </td>
    <td align="right">38 </td>
    <td align="right">100110 </td>
  </tr>
  <tr>
    <td align="right">9 </td>
    <td align="right">1001 </td>
    <td align="right">19 </td>
    <td align="right">10011 </td>
    <td align="right">29 </td>
    <td align="right">11101 </td>
    <td align="right">39 </td>
    <td align="right">100111 </td>
  </tr>
  <tr>
    <td align="right">10 </td>
    <td align="right">1010 </td>
    <td align="right">20 </td>
    <td align="right">10100 </td>
    <td align="right">30 </td>
    <td align="right">11110 </td>
    <td align="right">40 </td>
    <td align="right">101000 </td>
  </tr>
</table>
Now, an IP Address is four bytes, eight bits each, represented as decimal numbers with periods in between; for example, 10.5.72.230. This number can be represented in binary (remember when I said that IP Addresses are best expresses as 32-bit binary numbers? I <em>did </em> mention that, didn't I?) as b00001010.00000101.01001000.11100110. (The "b" means "binary"; that and the periods are added for your convenience.) Now, 2 32 (two to the thirty-second power) is 4294967296, or just over four billion. So, theoretically, there are over four billion IP addresses available to the world; so why is there a shortage? (Oh yeah, have you heard? There's a shortage. Last I checked, they're projecting to run out of IP addresses around the year 2025.) Well, as it turns out, trying to keep track of where four billion individual hosts are would be pretty much impossible for equipment today, and certainly impossible for equipment many years ago when TCP/IP routing was being developed. So, routing was (over)simplified by splitting the IP address space into "classes"; those IP addresses whose first byte was in the range 1-126 would belong to networks of 16,777,214 (2 24 -2) hosts; these were called "Class A" networks, and there are 127 of them. In Class A networks, the first eight bits are the "network portion", and the last 24 bits are the "host portion." Those IP addresses whose first byte was in the range 128-191 were called "Class B" networks of 65,534 (2 16 -2) hosts, and there were 16,384 (that's (192-128)*256) of them. That's 16 bits for the network portion, and 16 bits for the host portion. "Class C" networks, where the first byte is in the range 192-223, have a 24 bit network portion, and an 8 bit host portion. Note how neatly everything lines up on byte boundaries:
<table>
  <tr>Class Network bits Network Mask Network Mask (binary) </tr>
  <tr>
    <td>A </td>
    <td>8 </td>
    <td>255.0.0.0 </td>
    <td>b11111111.00000000.00000000.00000000 </td>
  </tr>
  <tr>
    <td>B </td>
    <td>16 </td>
    <td>255.255.0.0 </td>
    <td>b11111111.11111111.00000000.00000000 </td>
  </tr>
  <tr>
    <td>C </td>
    <td>24 </td>
    <td>255.255.255.0 </td>
    <td>b11111111.11111111.11111111.00000000 </td>
  </tr>
</table>
Now, since it's unlikely that a network administratior is going to want to have some 16,777,214 (nearly seventeen million) hosts on the same network segment(!), network administators were allowed to administratively split up their networks by subnetting them. Routing on the Internet backbones was fairly simple... until they started to hit the Class C networks hard. If your company needed 1,000 IP addresses, you'd probably get four Class C networks to accomodate them... but that would add four individual routes propagated to every "backbone" router on the Internet! Hence the need to split up networks on other than just byte boundaries. <br />
<br />
This is where everything got hard. <br />
<br />
It turns out that you can combine four "Class C" networks together into one routing table entry by using a subnet mask (aka Network Prefix) of 255.255.252.0. But not just any four; as it happens, they must be contiguous, and the third byte of the first network must be a multiple of four (like the number 204 is.) If you want to join eight of them together, the first network must be a multiple of eight (which the number 204 is not.) If you want to join ten networks together... well, you can't. Ten is not a power of two. Funny how everything follows powers of two... <br />
<br />
<h3>B. Boolean Logic and The Binary "AND" </h3>
Named after the nineteenth-century mathematician George Boole, Boolean logic is a form of algebra in which all values are reduced to either TRUE (1) or FALSE (0). All math performed by modern computers is done using Boolean algebra. A few basic operations:
<table>
  <tr>Operation Result Examples </tr>
  <tr>
    <td>AND </td>
    <td>true if A <em>AND </em> B are true </td>
    <td>1 AND 1 = 1 <br />
      1 AND 0 = 0 <br />
      0 AND 1 = 0 <br />
      0 AND 0 = 0 </td>
  </tr>
  <tr>
    <td>OR </td>
    <td>true if A <em>OR </em> B are true </td>
    <td>1 OR 1 = 1 <br />
      1 OR 0 = 1 <br />
      0 OR 1 = 1 <br />
      0 OR 0 = 0 </td>
  </tr>
  <tr>
    <td>XOR (eXclusive Or) </td>
    <td>true if <em>either </em> A <em>or </em> B are true </td>
    <td>1 XOR 1 = 0 <br />
      1 XOR 0 = 1 <br />
      0 XOR 1 = 1 <br />
      0 XOR 0 = 0 </td>
  </tr>
  <tr>
    <td>NOT </td>
    <td>opposite of A </td>
    <td>NOT 1 = 0 <br />
      NOT 0 = 1 </td>
  </tr>
</table>
<br />
The binary "and" operation is often used when you want to see only certain bits of a given byte-- a procedure called "masking." Some of you may have seen a similar thing in school; some of my teachers used to conduct multiple-choice tests where you would fill in a circle cooresponding to the answer you thought was correct. The teacher would then take an overlay, or mask, and place it over the answer sheet. This overlay had holes only where the marking spots for the correct answers were, and the teacher would mark any answers where he/she didn't see a mark, as incorrect. The subnet mask is used in this fashion by the computer to determine which address bits are in the network portion of an IP address, and which bits are used for the host, or workstation, portion. <br />
<h3>C. The Subnet "Mask" </h3>
The subnet mask is used to figure out what network you're on. The reason it's called a "mask" is the same reason the tape you use to cover trim when painting is called "masking tape"; you use it to cover up the parts you don't want to deal with right now. Did you notice how, in a binary AND, any time B is zero, the result is zero? And any time B is one, the result is whatever A is? Hmmm..... <br />
<br />
The primary use of the subnet mask (from our perspective at the Near Side of the 'Net) is for workstations to determine whether or not the server or workstation they're trying to talk to (the "destination IP address") is on the same subnet as itself; if the destination IP address is on your subnet, you'll send the IP packet directly to the other computer via the Ethernet or Token Ring (or whatever) network you're on, without bothering the router... at all! <strong>The first routing decision made on an IP packet is made by the workstation sending it; it decides whether or not to send the packet to a router. </strong> Doing this is a four step process:
<ol>
  <li><strong>Step 1: </strong> Convert the IP Addresses to Binary. <br />
    If necessary, the IP address is converted from the familiar dotted-decimal into a 32-bit binary value. It sucks as much for the computer to do it as it does for humans to do it, but computers generally complain less, and they're good at math :-) </li>
  <li><strong>Step 2: </strong> Apply Source subnet mask to Source addresses: <br />
    The <strong>network portion </strong> of the <strong>workstation's IP address </strong> is determined by performing a binary AND operation on the workstation's IP address and its subnet mask. This operation "masks off" all of the bits of the "host portion" of the IP address, and leaves the "network portion" behind for comparison with the destination's network portion. Hey, wait a minute? How do we know what the subnet mask of the destination is? </li>
  <li><strong>Step 3: </strong> Apply <strong>Source </strong> subnet mask to <strong>Destination </strong> addresses: <br />
    As it happens, we don't care what the subnet mask of the destination is. We only care if the destination is on our same network segment! <strong>Since every workstation on our network segment shares the same subnet mask, we can apply our subnet mask to the destination to determine if its network portion matches ours. </strong> So, <strong>the network portion of the destination workstation's IP address that we can use to see if it matches ours </strong> is determined by performing a binary AND operation on the destination IP address and <strong>our subnet mask </strong>. </li>
  <li><strong>Step 4: </strong> Compare the derived <strong>network </strong> portions for equality: <br />
    At this point, we can compare the network portions we have masked from the source and destination IP addresses to see if they're the same. If they are, then we <strong>must be on the same subnet </strong> so we send the packet directly; if they are different, even by only one bit, the destination is on another network segment...somewhere. We don't know where. Maybe the router does... </li>
</ol>
OK, so let's try this a few times ourselves; get a few IP addresses and subnet masks together and plug 'em into Daryl's Subnet Calculator! (The next section of the Primer.) Requires JavaScript to be enabled on your browser. If you're reading a hard copy of this, the full URL is http://ipprimer.windsorcs.com/subnet.cfm . <br />
<br />
Remember the part about combining four "Class C" networks together? Watch your binary arithmetic: <br />
<em>(network prefix bits shown in green ) </em>
<table>
  <tr>Networks Networks, in Binary </tr>
  <tr>
    <td>192.168.8.0 </td>
    <td>b 11000000.10101000.000010 00.00000000 </td>
  </tr>
  <tr>
    <td>192.168.9.0 </td>
    <td>b 11000000.10101000.000010 01.00000000 </td>
  </tr>
  <tr>
    <td>192.168.10.0 </td>
    <td>b 11000000.10101000.000010 10.00000000 </td>
  </tr>
  <tr>
    <td>192.168.11.0 </td>
    <td>b 11000000.10101000.000010 11.00000000 </td>
  </tr>
  <tr>
    <td>Mask, 255.255.252.0 </td>
    <td>b 11111111.11111111.111111 00.00000000 </td>
  </tr>
</table>
Notice how all of the bits above the ones in the subnet mask stay the same; following the rules above, all hosts on these networks, if you apply the mask, are on the same network. This was called "supernetting", but now is called "CIDR Routing", pronounced "Cider Routing". <br />
<br />
Doing it wrong: <br />
<em>(carefully watch the network-portion bit in <strong>red </strong>) </em>
<table>
  <tr>Networks Networks, in Binary </tr>
  <tr>
    <td>192.168.10.0 </td>
    <td>b 11000000.10101000.00001 <strong>0 </strong>10.00000000 </td>
  </tr>
  <tr>
    <td>192.168.11.0 </td>
    <td>b 11000000.10101000.00001 <strong>0 </strong>11.00000000 </td>
  </tr>
  <tr>
    <td>192.168.12.0 </td>
    <td>b 11000000.10101000.00001 <strong>1 </strong>00.00000000 </td>
  </tr>
  <tr>
    <td>192.168.13.0 </td>
    <td>b 11000000.10101000.00001 <strong>1 </strong>01.00000000 </td>
  </tr>
  <tr>
    <td>Mask, 255.255.252.0 </td>
    <td>b 11111111.11111111.11111 <strong>1 </strong>00.00000000 </td>
  </tr>
</table>
Oops-- seems the sixth bit of the third byte changed within the network prefix portion (the part above the 1's in the subnet mask), so with the given subnet mask (22 bits, or 255.255.252.0), 10.0 and 11.0 would ALWAYS be on a different network aggregation than networks 12.0 and 13.0. Confused? Play with it in the <a href="subnet.cfm">Subnet Calculator </a>, and compare the network portions. <br />
<br />
<h3>D. "Slash" Notation </h3>
Subnet masks are often abbreviated using a forward slash "/" and the number of "one" bits in the mask. For example, a network 192.168.1.0 with a subnet mask of 255.255.255.0 can be expressed as 192.168.1.0/24 (since 255.255.255.0 is 24 binary ones followed by eight binary zeros.) Therefore, a /25 subnet is a subnet with a mask of 255.255.255.128, and a /26 subnet has a mask of 255.255.255.192, etc.
<h3>E. A Neat Trick </h3>
Now that you actually understand the binary arithmetic behind subnet masking (well, I hope you do, anyway) we can cover some of the neat tricks for computing subnet masks. To determine the number of hosts on a given subnet (assuming the subnet is smaller than class "C",) simply subtract the last number of the subnet mask from 256. For example, a subnet mask of 255.255.255.224 has 32 hosts (256-224=32.) Then you can just divide the result into 256 to determine the number of subnets (256/32=8.) So, using a subnet mask of 255.255.255.224 gives you 8 subnets of 32 hosts each. Of course, this only works when you are subtracting a number that is a power of two (1, 2, 4, 8, 16, 32, 64, or 128.) When the network prefix is larger than class "C", you can determine how many class "C" networks are aggregated by subtracting the third byte from 256-- so a network prefix of 255.255.240.0 is an aggregation of (256-240) 16 class "C" networks. <br />
<em>Thanks to Gael M. for this tip. </em>
<h3>F. In closing... </h3>
Why all this crap about binary arithmetic? Do I <em>have </em> to know this stuff? I'm afraid so; subnet masks are created and used on a bit-by-bit basis; in order to effectively use subnet masks that <em>don't </em> fall on byte boundaries (like 255.255.255.0 does), you have to determine what hosts are on each subnet by using binary arithmetic. It sucks, it's hard, it's confusing (espically since IP addresses and masks are expressed in decimal instead of hexadecimal notation) but you must use and understand IP addresses and subnet masks as binary. <br />
<br />
<br />
<p>&nbsp;</p>
        <h3>&nbsp;</h3>
        <h3>&nbsp;</h3>
        <h3>&nbsp;</h3>
        <h3>&nbsp;</h3>
        <h3>&nbsp;</h3>
        <h3>&nbsp;</h3>
        <h3>&nbsp;</h3>
        <h3>&nbsp;</h3>
        <h3>Multicast </h3>
        <p>Uhh... Multicast is kinda big, we'll get to it later. <br />
</p>
        <p>T1 lines are connected through a serial interface.</p>
        <p>&nbsp;         </p>
        <p>&nbsp;</p>
        <p>&nbsp;</p>
        <p>&nbsp;  </p>
        <p><a href="#TOP">Top</a></p>
        <blockquote>
          <p></p>
        </blockquote>
  </div>
      <div class="story">
        <blockquote>&nbsp;</blockquote>
      </div>
</div>
<!-- end masthead -->
</body>
</html>
